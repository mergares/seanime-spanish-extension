{
  "id": "local-animeflv-provider",
  "name": "Local AnimeFLV Streaming Provider",
  "description": "Stream anime from a locally hosted jimov API using the AnimeFLV provider with search capability.",
  "manifestURI": "https://raw.githubusercontent.com/mergares/share/refs/heads/main/manifest.json",
  "version": "1.0.0",
  "author": "User",
  "type": "onlinestream-provider",
  "language": "javascript",
  "lang": "multi",
  "payload": "class Provider {\\n  constructor() {\\n    // Base URL pointing to your locally running jimov API (AnimeFLV provider).\\n    this.base = \"http://100.91.179.28:3003/anime/flv\";\\n  }\\n\\n  /**\\n   * Returns settings for the provider.\\n   * episodeServers is a list of server names that users can choose from.\\n   * supportsDub tells Seanime whether this provider offers dubbed audio.\\n   */\\n  getSettings() {\\n    return {\\n      episodeServers: [\\"default\\"],\\n      supportsDub: false\\n    };\\n  }\\n\\n  /**\\n   * Search for an anime using AnimeFLV's search endpoint exposed by the local API.\\n   * Seanime passes a SearchOptions object with a `query` field.\\n   * We ignore optional fields like `dub` and `year`.\\n   * Returns an array with a single SearchResult.\\n   */\\n  async search(opts) {\\n    const query = opts.query || \"\";\\n    if (!query) {\\n      return [];\\n    }\\n    const url = `${this.base}/search/${encodeURIComponent(query)}`;\\n    try {\\n      const resp = await fetch(url);\\n      if (!resp.ok) {\\n        return [];\\n      }\\n      const data = await resp.json();\\n      if (!data || !data.name) {\\n        return [];\\n      }\\n      // Use slug from the response or derive from the URL.\\n      const slug = data.slug || (data.url ? data.url.split('/') .pop() : data.name.replace(/\\s+/g, '-').toLowerCase());\\n      return [{\\n        id: slug,\\n        title: data.name,\\n        url: slug,\\n        subOrDub: 'sub'\\n      }];\\n    } catch (err) {\\n      // Fail quietly.\\n      return [];\\n    }\\n  }\\n\\n  /**\\n   * Fetches the episode list for an anime.\\n   * The `id` is the slug returned by the search() method.\\n   * Returns an array of EpisodeDetails with id, number, url and title.\\n   */\\n  async findEpisodes(id) {\\n    if (!id) {\\n      return [];\\n    }\\n    const url = `${this.base}/name/${id}`;\\n    try {\\n      const resp = await fetch(url);\\n      if (!resp.ok) {\\n        return [];\\n      }\\n      const data = await resp.json();\\n      const episodes = data && data.episodes ? data.episodes : [];\\n      const results = [];\\n      for (const ep of episodes) {\\n        // Extract slug from the API’s episode URL (e.g. /anime/flv/episode/one-piece-1).\\n        const epSlug = ep.url ? ep.url.split('/').pop() : ep.number.toString();\\n        const number = parseFloat(ep.number) || parseInt(ep.number) || results.length + 1;\\n        results.push({\\n          id: epSlug,\\n          number: number,\\n          url: epSlug,\\n          title: ep.name || `Episode ${number}`\\n        });\\n      }\\n      return results;\\n    } catch (err) {\\n      return [];\\n    }\\n  }\\n\\n  /**\\n   * Retrieves video sources for an episode.\\n   * Seanime passes the selected episode and server name.\\n   * We fetch the episode information from the local API and map the server list to Seanime’s structure.\\n   */\\n  async findEpisodeServer(episode, server) {\\n    const epId = episode.id;\\n    if (!epId) {\\n      return { server: server || 'default', headers: {}, videoSources: [] };\\n    }\\n    const url = `${this.base}/episode/${epId}`;\\n    try {\\n      const resp = await fetch(url);\\n      if (!resp.ok) {\\n        return { server: server || 'default', headers: {}, videoSources: [] };\\n      }\\n      const data = await resp.json();\\n      const servers = data && data.servers ? data.servers : [];\\n      // Pick the requested server if provided, otherwise choose the first available.\\n      let chosen = null;\\n      if (server && server !== 'default') {\\n        chosen = servers.find(s => s.name && s.name.toLowerCase() === server.toLowerCase());\\n      }\\n      if (!chosen && servers.length > 0) {\\n        chosen = servers[0];\\n      }\\n      if (!chosen) {\\n        return { server: server || 'default', headers: {}, videoSources: [] };\\n      }\\n      const fileUrl = chosen.file_url || chosen.url;\\n      if (!fileUrl) {\\n        return { server: chosen.name || server || 'default', headers: {}, videoSources: [] };\\n      }\\n      const type = fileUrl.includes('.m3u8') ? 'm3u8' : 'mp4';\\n      return {\\n        server: chosen.name || server || 'default',\\n        headers: {},\\n        videoSources: [{\\n          url: fileUrl,\\n          type: type,\\n          quality: 'auto',\\n          subtitles: []\\n        }]\\n      };\\n    } catch (err) {\\n      return { server: server || 'default', headers: {}, videoSources: [] };\\n    }\\n  }\\n}"
}
