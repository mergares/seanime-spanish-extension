{
  "id": "jimov",
  "name": "Jimov",
  "version": "1.0.0",
  "manifestURI": "https://raw.githubusercontent.com/mergares/share/refs/heads/main/tioanime.json",
  "language": "typescript",
  "type": "onlinestream-provider",
  "description": "Jimov is an online stream provider for anime with both sub and dub support, powered by Monoschinos implementation.",
  "author": "Your Name",
  "icon": "https://raw.githubusercontent.com/your-username/seanime-extensions/main/jimov/logo.png",
  "website": "https://jimov.ren.com",
  "lang": "en",
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n\nclass Provider {\n  private baseUrl = \"https://jimov.ren.com\";\n  private apiUrl = \"https://jimov.ren.com/api\";\n\n  getSettings(): Settings {\n    return {\n      episodeServers: [\"Monoschinos\", \"Monoschinos-2\", \"Monoschinos-3\"],\n      supportsDub: true,\n    };\n  }\n\n  async search(query: SearchOptions): Promise<SearchResult[]> {\n    try {\n      const res = await fetch(\n        `${this.apiUrl}/search?q=${encodeURIComponent(query.query)}&limit=24&page=1`,\n        {\n          headers: {\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n            \"Accept\": \"application/json\",\n            \"Referer\": this.baseUrl + \"/\",\n            \"Origin\": this.baseUrl,\n            \"Content-Type\": \"application/json\",\n          },\n        }\n      );\n    \n      if (!res.ok) {\n        throw new Error(`Search request failed: ${res.status}`);\n      }\n    \n      const json = await res.json();\n      const results: SearchResult[] = [];\n    \n      // Handle different response formats from Monoschinos API\n      const animeList = json?.data || json?.results || json?.anime || [];\n    \n      for (const anime of animeList) {\n        const hasDub = anime.hasDub || anime.dub_available || false;\n        const subOrDub: SubOrDub = query.dub ? \"dub\" : \"sub\";\n    \n        // Only return dubs if requested and available\n        if (query.dub && !hasDub) continue;\n    \n        results.push({\n          id: `${anime.id || anime.mal_id}/${subOrDub}`,\n          title: anime.title || anime.name,\n          url: `${this.baseUrl}/anime/${anime.slug || anime.id}`,\n          subOrDub,\n        });\n      }\n    \n      return results;\n    } catch (error) {\n      console.error('Search error:', error);\n      return [];\n    }\n  }\n\n  async findEpisodes(Id: string): Promise<Episode[]> {\n    try {\n      const [id, lang] = Id.split(\"/\");\n      const subOrDub: SubOrDub = lang === \"dub\" ? \"dub\" : \"sub\";\n\n      const epRes = await fetch(\n        `${this.apiUrl}/anime/${id}/episodes?type=${subOrDub}`,\n        {\n          headers: {\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n            \"Accept\": \"application/json\",\n            \"Referer\": this.baseUrl + \"/\",\n            \"Origin\": this.baseUrl,\n            \"Content-Type\": \"application/json\",\n          },\n        }\n      );\n\n      if (!epRes.ok) {\n        throw new Error(`Episode request failed: ${epRes.status}`);\n      }\n\n      const epJson = await epRes.json();\n      const episodes: Episode[] = [];\n\n      // Handle different episode response formats\n      const episodeList = epJson?.episodes || epJson?.data || epJson?.results || [];\n\n      for (const ep of episodeList) {\n        episodes.push({\n          id: `${id}/${subOrDub}`,\n          number: ep.number || ep.episode_number,\n          title: ep.title || `Episode ${ep.number || ep.episode_number}`,\n          url: \"\",\n        });\n      }\n\n      return episodes;\n    } catch (error) {\n      console.error('Find episodes error:', error);\n      return [];\n    }\n  }\n\n  async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise<EpisodeServer> {\n    try {\n      const [id, subOrDubRaw] = episode.id.split(\"/\");\n      const subOrDub: SubOrDub = subOrDubRaw === \"dub\" ? \"dub\" : \"sub\";\n    \n      // Server mapping for Monoschinos implementation\n      const serverMap: Record<string, string> = {\n        \"Monoschinos\": \"monoschinos\",\n        \"Monoschinos-2\": \"monoschinos2\",\n        \"Monoschinos-3\": \"monoschinos3\",\n      };\n    \n      const serverType = serverMap[_server] || \"monoschinos\";\n    \n      const sourcesUrl = `${this.apiUrl}/anime/${id}/episode/${episode.number}/sources?type=${subOrDub}&server=${serverType}`;\n    \n      const res = await fetch(sourcesUrl, {\n        headers: {\n          \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\",\n          \"Accept\": \"application/json\",\n          \"Referer\": this.baseUrl + \"/\",\n          \"Origin\": this.baseUrl,\n          \"Content-Type\": \"application/json\",\n        },\n      });\n\n      if (!res.ok) {\n        throw new Error(`Sources request failed: ${res.status}`);\n      }\n  \n      const json = await res.json();\n      const sources = json?.sources || json?.data || [];\n  \n      if (!sources.length) throw new Error(\"No video sources found\");\n  \n      // Find the best quality source\n      const streamSource = sources.find((s: any) => s.type === \"hls\") ||\n                           sources.find((s: any) => s.type === \"mp4\") ||\n                           sources[0];\n  \n      if (!streamSource?.url && !streamSource?.file) throw new Error(\"No valid stream file found\");\n  \n      // Handle subtitles\n      const subtitleTracks = json?.subtitles || json?.tracks || [];\n      const subtitles = subtitleTracks\n        .filter((track: any) => track.kind === \"captions\" || track.type === \"subtitle\")\n        .map((track: any, index: number) => ({\n          id: `sub-${index}`,\n          language: track.label || track.language || \"Unknown\",\n          url: track.url || track.file,\n          isDefault: !!track.default,\n        }));\n  \n      return {\n        server: _server,\n        headers: {\n          \"Access-Control-Allow-Origin\": \"*\",\n          \"Access-Control-Allow-Headers\": \"*\",\n          \"Access-Control-Allow-Methods\": \"*\",\n          \"Referer\": this.baseUrl,\n        },\n        videoSources: [\n          {\n            url: streamSource.url || streamSource.file,\n            type: streamSource.type || \"hls\",\n            quality: streamSource.quality || \"auto\",\n            subtitles,\n          },\n        ],\n      };\n    } catch (err) {\n      console.warn(`Failed on ${_server}`, err);\n      throw new Error(`No stream found for ${_server}`);\n    }\n  }\n}"
}
